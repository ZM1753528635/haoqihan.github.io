<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker的常用命令]]></title>
    <url>%2F2019%2F01%2F13%2Fdocker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.查看docker信息(version,info)12345# 查看版本docker version# 显示docker系统的信息docker info 2.对image的操作(search,pull,images,rmi,history) view plaincopy1234567891011121314# 检索imagedocker search image_name# 下载imagedocker pull image_name# 列出镜像列表:-a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs docker images# 删除一个或多个镜像 -f, --force=false Force; --no-prune=false Do not delete untagged parents docker rmi image_name # 显示一个镜像的历史 --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs docker history image_name 3.启动容器(run)​ docker容器可以理解为在沙盒中运行的进程,这个沙盒包含该进程所必须的资源,包括文件系统,系统类库,shell环境等,但这个沙盒默认是不会运行任何程序的,你需要在沙盒中运行一个进程来启动某个容器,这个进程是该容器的唯一进程,所以当该进程结束时,容器也会结束 12345678# 在容器中运行"echo" 命令,输出"hello word"docker run image_name echo "hello word"# 交互式进入容器中docker run -i -t image_name /bin/bash# 在容器中安装新的程序docker run image_name apt-get install -y app_name ​ 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。 4.查看容器(ps) view plaincopy12345678# 列出当前所有运行的containerdocker ps# 列出所有的containerdocker ps -a# 列出最近一次启动的containerdocker ps -1 5.保存对容器的修改(commit)​ 当你对一个容器进行修改之后(通过容器中运行某一个命令),可以把容器的修改保存下来,这样下一次可以从保存后的最新状态运行该容器 view plaincopy 12# 保存对容器的修改 -a, --author="" Author; -m, --message="" Commit message docker commit ID new_image_name ​ Note:image相当于一个类,container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。 6.对容器的操作(rm、stop、start、kill、logs、diff、top、cp、restart、attach ) view plaincopy1234567891011121314151617181920212223242526272829# 删除所有容器docker rm `docker ps -a -q`# 删除单个容器docker rm Name/ID# 停止,启动,杀死一个容器docker stop Name/IDdocker start Name/IDdocker kill Name/ID# 从一个容器中取日志docker logs Name/ID# 列出一个容器里面被改变的文件或者目录,list列表会显示三种事件,A 增加 D删除 C被改变docker diff Name/ID# 显示一个运行的容器里面的进程信息docker top Name/ID# 从容器里面拷贝文件/目录到本地一个路径docker cp Name:/container_path to_path docker cp ID:/container_path to_path # 重启一个正在运行的容器docker restart Name/ID# 附加到一个运行的容器上docker attach ID ​ Note:attach命令允许你查看或影响一个运行的容器,你可以在同一时间attach同一个容器,你也可以从一个容器中脱离出来,是CTRL + C 7.保存和加载镜像(save load)​ 当需要把一台机器上的镜像迁移到另一台机器上的时候,需要保存于加载镜像 1234567891011# 保存镜像到一个tar包 -o, --output="" Write to an file docker save image_name -o file_path# 加载一个tar包格式的镜像 -i, --input="" Read from a tar archive file docker load -i file_path# 机器adocker save image_name &gt; /home/save.tar# 使用scp将save.tar拷到机器b上,然后docker load &lt; /home/save.tar 8.登录 registry server (login) view plaincopy12# 登录register server -e, --email="" Email; -p, --password="" Password; -u, --username="" Username docker login 9.发布image(push) copy12# 发布docker镜像docker push new_image_name 10.根据Dockerfile构建一个容器1#]]></content>
      <categories>
        <category>运维开发之路</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker的安装]]></title>
    <url>%2F2019%2F01%2F13%2Fdocker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker安装1.Ubuntu系统Ubuntu安装docker大概要区分为Ubuntu14.04之前和Ubuntu14.04之后两种方法 如果是14.04版本之后的Ubuntu,其内核版本以及一些依赖包都已经准备充分,直接运行下载最新版docker即可: 1curl -sSL https://get.docker.com/ | sh 新安装的系统可能会没有curl服务,需要下载: 1sudo apt-get update $ sudo apt-get install curl 顺便提及,docker应用的启动需要root的管理员权限,最好在安装之前获取root权限,啰嗦一下如何方便地将用户转为root角色 1sudo su 然后根据提示输入当前用户密码即可. 下载好之后可以测试,下载hello-world或者busybox测试一下. 1sudo docker run hello-world docker run是docker的运行命令.后面是容器名称,如果本地没有该命令,则docker服务会从docker仓库下载该容器,然后运行. 测试打印 hello world就说明成功了.可用docker info查看安装信息. 最好使用新版本的Ubuntu安装docker.如果是12.04或者13.04版本的则需要先安装一些依赖性的包 先要升级内核(同样先获取root权限) 12sudo apt-get updatesudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring Docker有deb格式的安装包 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9 后把Docker的库添加到apt的源列表中，更新并安装lxc-docker包。 1234sudo sh -c "echo deb http://get.docker.io/ubuntu docker main\&gt; /etc/apt/sources.list.d/docker.list"sudo apt-get updatesudo apt-get install lxc-docker 如果有警告信息,yes即可 2.centos系统和rhel这两个系统在新的版本里面都自带了docker,只不过docker版本不一定是最新的,我记得centos7里面的自带的docker是0.9,当前最新docker版本已经到了0.11,不过不会影响试用. 系统安装需要保证内核版本在3.10以上,低于这个版本的理论上也可以安装,只不过需要大牛去研究一番,我们直接升级内核 yum安装带aufs模块的3.10内核 123cd /etc/yum.repos.d wget http://www.hop5.in/yum/el6/hop5.repoyum install kernel-ml-aufs kernel-ml-aufs-devel 修改grub的主配置文件/etc/grub.conf，设置default=0，表示第一个title下的内容为默认启动的kernel（一般新安装的内核在第一个位置）,之后重启. 执行安装: 1curl -sSL https://get.docker.com/ | sh 启动服务: 1sudo service docker start 如果是系统版本7以上,已经自带docker包,直接运行: 1yum install docker]]></content>
      <categories>
        <category>运维开发之路</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible的基本使用]]></title>
    <url>%2F2019%2F01%2F13%2Fansible%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一.简介ansible是什么东西?官方的title是“Ansible is Simple IT Automation”——简单的自动化IT工具。这个工具的目标有这么几项：让我们自动化部署APP；自动化管理配置项；自动化的持续交付；自动化的（AWS）云服务管理。 所有的这几个目标本质上来说都是在一个台或者几台服务器上，执行一系列的命令而已。就像我之前有介绍过的Fabric，以及我们基于Fabric开发的自动化应用部署的工具： Essay 。都是做了这么个事——批量的在远程服务器上执行命令 。 那么fabric和ansible有什么差别呢？简单来说fabric像是一个工具箱，提供了很多好用的工具，用来在Remote执行命令，而Ansible则是提供了一套简单的流程，你要按照它的流程来做，就能轻松完成任务。这就像是库和框架的关系一样。 当然，它们之间也是有共同点的——都是基于 paramiko 开发的。这个paramiko是什么呢？它是一个纯Python实现的ssh协议库。因此fabric和ansible还有一个共同点就是不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的。 二.安装及初步使用 编译安装,此处使用yum 12yum install epel # 下载epel源yum install -y ansible # 安装ansible 2.查看ansible生成的文件 1rpm -ql ansible 3.查看ansible生成的命令 1234ansible # 用来执行ansible的一些命令ansible-doc # 用来查看ansible的模块的帮助信息ansible-playbook # 用来执行playbookansible-galaxy # 用来下载第三方的playbook 4.ansible命令模式 1234567ansible &lt;host-pattern&gt; [options]-a MODULE_ARGS # 模块的参数-C --check # 测试,干跑-f FORKS # 指定并发数--list-hosts # 列出host-pattern主机--syntax-check # 语法检查-m MODULE_NAME # 指定模块 5.ansible第一条命令 1ansible all -m ping # 跟系统自带的ping不一样 6.host-pattern格式 123456789101112131415[web]192.168.19.33192.168.19.44[db]192.168.19.55[cache]192.168.19.66www[001:006].example.com指定所有 all指定单台机器(指定多个机器)指定分组(多个分组)指定分组并集 # ansible "web:db" -m ping指定分组的交集 # ansible "web:&amp;db" -m ping指定分组的差集 # ansible "web:!db" -m ping 7.ansible-doc 12345Usage: ansible-doc [-l|-F|-s] [options] [-t &lt;plugin type&gt; ] [plugin]-a # 列出所有的模块-l # 列出ansible的模块-s # 片段式显示模块的信息 8.补充 123456789[name] #分组name=CentOS-$releasever - Base - mirrors.aliyun.com #这个分组的名字failovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ #分组的url,叫baseurl http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=0 # gpgcheck=1需要验证key文件,gpgcheck=0不验证keyenabled=1 #enabled=1 表示分组可用,enabled=0表示分组是不可用的gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #key文件 三.命令相关命令相关1.command 1234ansible web -m aommand "pwd"ansible web -a "chdir=/tmp/ mkdir /data2" # 切换到/tmp并执行pwdansible web -a "creates=/etc/ mkdir /data2" # 判断creates是否存在,真就忽略后面的操作ansible web -a "removes=/tmp/data mkdir /tmp/data2" # 判断removes是否存在,假就忽略后面的操作 2.shell 123ansible web -m shell -a "echo 'test1'|password --stdin test1" # 修改密码ansible 192.168.19.9 -m shell "/root/a.sh" # 指定远程主机上的shell脚本ansible 192.168.19.2 -m shell -a "/root/a.py" # 指定远程主机上的python文件 3.sctipt 1ansible all -m script -a "/root/a.sh" # 执行管控机的shell脚本 文件相关1.copy复制管控机文件到被管控机 123456ansible web -m copy -a "src=/etc/xxx dest=/data/xxx" # src指定源文件 dest指定目标文件ansible web -m copy -a "src=/etc/xxx dest=/data/xxx backup=yes" # backup备份ansible web -m copy -a "src=/etc/init.d dest=/data/" # 复制目录和目录下的文件到远程主机,远程主机也是一个文件夹ansible web -m copy -a "src=/etc/init.d/ dest=/data/" # 复制目录下的文件ansible web -m copy -a "src=/etc/xxx dest=/data/xxx backup=yes mode=600" # mode 指定权限,owner指定文件的属主,group用来指定属组ansible web -m copy -a "content='内容xxxxx' dest=/data10/xx.txt" # content 直接写内容 2.file 1234ansible db -m file -a "path=/data10 state=directory" # path指定地址,state=directory表示创建文件夹ansible db -m file -a "path=/data10/xxx state=touch" # state=touch 表示创建新文件ansible db -m file -a "path=/data10/test1 state=absent" # state=absent 代表删除ansible db -m file -a 'path=/data10/test10 src=/data10/test1 state=link' #src表示源文件,path是不是目标,state=link是不是创建一个软连接 3.fetch 1ansible db -m fetch -a "src=/etc/xxx dest/tmp" # src源地址(在被控机器上),dest目标地址(管控机上的地址)每个管控机的文件都生成了一个目录,会保持文件的原来目录结构 软件相关1.yum 1234ansible web -m yum -a "name=nginx state=installed" # 安装nginxansible web -m shell -a "rpm -qa | grep nginx" # 查看nginx是不是安装成功ansible web -m yum -a "name=nginx state=absent" # 卸载nginxansible web -m yum -a "name=redis,memcached" 2.pip 1ansible web -m pip -a "name=Django==1.11.15" 定时任务 cron 123ansible web -m cron -a "name=testjob minute=4 job='echo 哈哈 &gt; /tmp/xx.txt'" # 创建 name:指定的cron名字 minute:指定分钟 hour:指定小时 day:指定天 month:指定月 weekday:指定周 job:指定要执行的命令ansible web -m cron -a "name=testjob state=absent" # 删除任务ansible web -m cron -a "name=testjob minute=4 disabled=yes job='echo 哈哈 &gt; /tmp/xx.txt'" # disabled=yes表示禁用 用户相关 user 12ansible web -m user -a "name=客户1 home=/data/客户1" # 创建用户并指定家目录ansible web -m user -a "name=客户2 groups='xxx1,xxx2' home=/data/客户2" # groups='xxx1,xxx2' 指定用户的附加组 收集系统信息 setup 收集系统信息 1234567891011121314151617"ansible_all_ipv4_addresses" #ipv4简单信息"ansible_all_ipv6_addresses" #ipv6的简单信息"ansible_architecture": "x86_64", #系统架构"ansible_date_time": #系统时间"ansible_default_ipv4": #详细信息"ansible_devices": #磁盘信息"ansible_distribution_major_version": "7",#系统版本"ansible_distribution": "CentOS", #系统的发行商"ansible_distribution_file_variety": "RedHat", #系统系列"ansible_fqdn": "localhost.localdomain", #系统的主机名"ansible_hostname": "localhost",#简写主机名"ansible_kernel": "3.10.0-693.el7.x86_64", #系统的内核版本"ansible_os_family": "RedHat",# 系统的家族"ansible_processor_vcpus": 2, #cpu的个数"ansible_python_version": "2.7.5", # ansible所用python的版本 ansible web -m setup -a 'filter="*cpu*"' #filter搜索 启动应用 service 123enabled:#开机启动name:#服务的名称state: #操作 四.playbook的基本使用 playbook命令,建议:一个文件做一件事 1.基本格式 12345678ansible-playbook [options] playbook.yml-C # 干跑,检查-f FORKS # 用来做并发,来指定并发数--list-hosts #列出执行命令的主机--syntax-check # 检查语法--list-tasks #列出playbook要执行的任务列表-t TAGS, #指定要运行到tags-e EXTRA_VARS #给playbook传递变量 2.单个playbook 12345678#单个playbook- hosts: web #指定要运行命令的主机 remote_user: root # 指定运行命令的用户 tasks: #任务列表 - name: mkdir # 任务1,name是必须的 file: path=/data state=directory # 指定的模块: 模块的参数 - name: copyfile copy: src=/etc/fstab dest=/data/f 3.多个playbook 1234567891011121314##多个playbook- hosts: web remote_user: root tasks: - name: mkdir file: path=/data state=directory - name: copyfile copy: src=/etc/fstab dest=/data/f- hosts: db remote_user: root tasks: - name: wget shell: "wget -O /data/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo" 4.指定tags 123456789##指定tags- hosts: web remote_user: root tasks: - name: mkdir file: path=/data state=directory - name: copyfile copy: src=/etc/fstab dest=/data/f tags: copyfile 变量1.第一种 123456## 传递变量 -e"key=value"- hosts: web remote_user: root tasks: - name: yum &#123;&#123;pkg_name&#125;&#125; pkg yum: name=&#123;&#123;pkg_name&#125;&#125; 2.第二种 1234567- hosts: web remote_user: root vars: - pkg_name: memcached tasks: - name: yum &#123;&#123;pkg_name&#125;&#125; pkg yum: name=&#123;&#123;pkg_name&#125;&#125; 3.第三种 1234#在hosts文件里面写,值可以不同[web]192.168.19.9 pkg_name=nginx192.168.19.26 pkg_name=redis 4.第四种 12[web:vars]pkg_name=nginx 5.变量的应用顺序 1-e &gt; yml文件 &gt; hosts文件 #命令行里面是最高的,hosts文件是最低的 条件 when 条件判断 123456789- hosts: cache remote_user: root tasks: - name: copyfile1 copy: content='wusir zhenchou' dest=/tmp/a.txt when: ansible_os_family=="RedHat" #只有为真的时候才会执行上面的操作 - name: copyfile2 copy: content='alex gengchou' dest=/tmp/b.txt when: ansible_os_family=="OpenBSD" 循环with_items1.循环单个 12345678910111213- hosts: cache remote_user: root tasks: - name: create user user: name=&#123;&#123;item&#125;&#125; ## 循环下面的with_items with_items: - yuchao - yantao - name: create group group: name=&#123;&#123;item&#125;&#125;## 循环下面的with_items with_items: - yuchao2 - yantao2 2.循环嵌套 12345678910111213- hosts: cache remote_user: root tasks: - name: create group group: name=&#123;&#123;item&#125;&#125; with_items: - yuchao4 - yantao4 - name: create user user: name=&#123;&#123;item.name&#125;&#125; group=&#123;&#123;item.group&#125;&#125; #可以通过字典取值 with_items: - &#123;"name":yuchao3,"group":yuchao4&#125; - &#123;"name":yantao3,"group":yuchao4&#125; 模板文件1.模板的基本使用 12345678910- hosts: cache remote_user: root tasks: - name: install redis yum: name=redis - name: copyfile template: src=redis.conf.j2 dest=/etc/redis.conf ## 模板基于jinja2 - name: start service: name=redis state=started #模板文件放在templates,可以直接用相对路径去调用配置文件 roles(高级使用) 作用 结构清晰 可以重用 结构 12345tasks #目录是必须的,存放任务templates #是存放模板vars #用来存放变量 ### 切记,不能加-,加-报错files #用来存放文件mkdir -p &#123;nginx,uwsgi,mysql&#125;/&#123;tasks,templates,vars,files&#125; #创建目录结构的命令 补充生成公私钥 1ssh-keygen 复制公钥到远程主机 1ssh-copy-id 192.168.19.99 ping命令发送的是ICMP协议 查看用户相关 1234tail -l /etc/shadow 查看最后一个用户echo "testl" | password --stdin testl 设置用户密码,不需要二次确useradd # 创建用户默认的家目录在/home -d 可以指定用户的家目录groupadd # 用来创建用户组,用户组没有家目录 创建链接 12ln 创建硬链接 链接文件变更 源文件不变ln -s 创建软连接 链接文件变更 源文件变 pip的基本使用 123pip freeze &gt; file # 给当前的python模块做快照pip install -r xxx.txt # 安装pip list # 查看所有的python模块 crontab定时任务 1234567* */5 * * * job #/n 表示每隔n 0 */5 * * 3,6 job #3,6 表示周三和周六## 切记 最前面不能用*,表示每时每刻都在执行,一定要有一个时间## 应用场景: 打包日志,定期的同步时间,备份-e # 编辑-l # 列出-r # 删除 启动应用 12systemctl restart nginx # centos7中的操作应用service nginx restart # centos6里面的操作 查看系统内存使用量 1free -m 查看系统的内存使用量 Ad-hoc:命令行的意思 mv 的使用 1mv redis.conf&#123;,.j2&#125; == mv redis.conf redis.conf.j2 yum和rpm的基本使用 1234yum remove 卸载rpm redhat pk manageyum 自动解决依赖关系rpm 不会自动解决依赖关系 CI和CD的基本使用 12CI 持续交付 jenkins maven war包CD 持续集成 脚本去做 docker (最大的一个作用,到处运行 ) k8s 暂时关闭防火墙 1setenforce 0 #暂时关闭selinux uwsgi的配置 1234567891011121314151617[uwsgi]http = :8000 #端口#the local unix socket file than commnuincate to Nginxsocket = /data/mysite/mysite.socket #socket 只能本机使用# the base directory (full path)chdir = /data/mysite #当前工作目录# Django's wsgi filewsgi-file = mysite/wsgi.py #要执行的文件# maximum number of worker processesprocesses = 4 #进程数#thread numbers startched in each worker processthreads = 2 #线程数# clear environment on exitvacuum = truedaemonize = /data/mysite/uwsgi.log #后台启动,并提供日志py-autoreload=1 #py文件变更后uwsgi自动重启 kill -9 可以杀死父进程 启动uwsgi 1uwsgi --http :8000 --module mysite.wsgi ## --http 启动的端口 --module 项目.wsgi文件]]></content>
      <categories>
        <category>运维开发之路</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
</search>
